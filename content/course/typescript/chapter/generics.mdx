---
index: 9
title: "TypeScript Generics"
---

Greetings, TypeScript enthusiasts! This chapter dives into the exciting realm of generics, a powerful feature that empowers you to write reusable code that can work with various data types. Generics act as templates, allowing you to create functions and classes that can operate on a wide range of data without sacrificing type safety. Buckle up and get ready to explore the world of generics in TypeScript!

## 1. The Generics Advantage: Reusable Code with Type Flexibility

Imagine crafting a toolbox with compartments that can hold different types of tools (hammers, screwdrivers) – generics in TypeScript function similarly. They allow you to define functions and classes that can work with various data types while maintaining type safety. This promotes code reusability and reduces code duplication.

**Introduction to Generics:**

The `generic` keyword is used to define generic functions and classes in TypeScript:

```typescript
function identity<T>(value: T): T {
  // Generic function with type parameter 'T'
  return value;
}

let numberValue = identity(10);
console.log(numberValue); // Output: 10

let stringValue = identity("Hello World!");
console.log(stringValue); // Output: Hello World!
```

**Remember:**

- Generics introduce type parameters denoted by capital letters (e.g., `T`) that act as placeholders for actual data types when the function or class is used.
- This allows the same function or class to work with different data types without code duplication.

## 2. Unveiling Flexibility: Creating Generic Functions

Imagine a toolbox with a versatile tool that can sort different types of items (numbers, strings) – generic functions in TypeScript offer similar functionality:

```typescript
function sortItems<T>(items: T[]): T[] {
  // Generic function for sorting an array of any type
  return items.sort(); // Leverage built-in sort method (may require type-specific sorting logic)
}

let numbers = [3, 1, 4, 5, 2];
let sortedNumbers = sortItems(numbers);
console.log(sortedNumbers); // Output: [1, 2, 3, 4, 5] (sorted array of numbers)

let names = ["Alice", "Charlie", "Bob"];
let sortedNames = sortItems(names);
console.log(sortedNames); // Output: [Alice, Bob, Charlie] (sorted array of strings)
```

**Remember:**

- Generic functions can be defined to operate on arrays of any type (`T[]`).
- The specific behavior (e.g., sorting logic) might require adjustments based on the actual data type used.

## 3. Unveiling the Mystery: Generic Types and Constraints

Imagine a toolbox with compartments that can only hold specific tool types (hammers for nails, screwdrivers for screws) – generics in TypeScript can be constrained with type constraints:

```typescript
function getLength<T extends string | number>(value: T): number {
  // Generic function with type constraint
  return value.length; // Accessing 'length' property (requires string or number type)
}

let stringLength = getLength("Hello World!");
console.log(stringLength); // Output: 12

// getLength(true); // This will cause a compilation error because 'true' is not a string or number

let numberLength = getLength(100);
console.log(numberLength); // Output: 2
```

**Remember:**

- You can add constraints to generic types using the `extends` keyword. This ensures that the generic type can only be one of the specified types (e.g., `string` or `number` in this case).
- This enforces type safety and prevents errors by restricting the types that can be used with the generic function.

## 4. Code Example: Utilizing Generics (Data Repository)

Let's build a simple generic data repository example to illustrate generics in action:

```typescript
class DataRepository<T> {
  private data: T[];

  constructor(initialData: T[]) {
    this.data = initialData;
  }

  getItem(id: number): T | null {
    return this.data.find((item) => item.id === id) || null; // Assuming items have an 'id' property
  }

  addItem(newItem: T): void {
    this.data.push(newItem);
  }
}

let numberRepository = new DataRepository<number>([1, 2, 3]);
numberRepository.addItem(4);

let stringRepository = new DataRepository<string>(["Hello", "World"]);
stringRepository.addItem("TypeScript!");

console.log(numberRepository.getItem(2)); // Output: 3 (assuming item with id 2 exists)
console.log(stringRepository.getItem(1)); // Output: World (assuming item at index 1 exists)
```

**Explanation:**

1. We define a generic `DataRepository` class that can store and manage data of any type (`T`).
2. The constructor accepts an initial array of the generic type (`T[]`).
3. Methods like `getItem` and `addItem` operate on the generic data type, providing flexibility for storing different data types.

**Remember:**

- Generics empower you to create reusable components like repositories that can work with various data structures without code duplication.

## Conclusion: Mastering the Art of Generics

By understanding generic function and class creation, type constraints, and their applications, you've equipped yourself with a powerful tool for writing flexible and type-safe code in TypeScript. Generics promote code reusability, maintainability, and reduce the risk of runtime errors. As you progress, explore advanced topics like generic interfaces, utility types, and mapped types to further enhance your generic programming skills in TypeScript.

**Remember:**

- Mastering generics takes practice and a good understanding of type systems.
- Leverage generics strategically to create reusable and type-safe components for your TypeScript projects.

## Additional Resources

Here are some resources for further exploration:

- [TypeScript Handbook - Generics](https://www.typescriptlang.org/docs/handbook/generics.html)
- [Learn TypeScript - Generics](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
- [TypeScript Deep Dive Book - Generics](https://basarat.gitbook.io/typescript/)

By incorporating these advanced concepts and leveraging the provided resources, you'll be well-equipped to design and implement robust generic components for your TypeScript projects. Happy coding!
