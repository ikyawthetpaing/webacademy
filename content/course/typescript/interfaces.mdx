---
index: 5
title: "TypeScript Interfaces"
---

Welcome, TypeScript enthusiasts! This chapter delves into the world of interfaces, a powerful tool for defining the structure (or "shape") of objects in your code. Interfaces lay the foundation for type safety and code clarity, ensuring objects adhere to a predefined contract. Buckle up and get ready to craft robust and well-structured objects using interfaces in TypeScript!

## 1. The Interface Advantage: Defining Object Blueprints

Imagine an architect creating a detailed blueprint for a building – interfaces in TypeScript function similarly. They act as contracts that specify the properties and optional methods an object must implement. This ensures consistency and type safety in your code.

**Declaring Interfaces:**

Interfaces are declared using the `interface` keyword followed by a name and curly braces (`{}`) to define its properties:

```typescript
interface User {
  name: string; // Property with a string type
  age: number; // Property with a number type
}

let user1: User = { name: "Alice", age: 30 }; // Object adhering to the User interface

console.log(user1.name); // Output: Alice (accessing properties)
```

**Remember:**

- Interfaces define the expected structure of objects, promoting code clarity and maintainability.
- By adhering to an interface, you ensure objects have the necessary properties and their corresponding data types.

## 2. Unveiling Flexibility: Optional and Readonly Properties

Imagine a blueprint allowing for an optional room or a section marked as read-only – interfaces in TypeScript offer similar flexibility:

**a) Optional Properties:**

- Use a question mark (`?`) after a property's name to make it optional.
- Objects implementing the interface can have or omit the optional property.

```typescript
interface Product {
  name: string;
  price: number;
  description?: string; // Optional property (may or may not be present)
}

let product1: Product = { name: "T-Shirt", price: 19.99 }; // Valid without description
let product2: Product = {
  name: "Jeans",
  price: 49.99,
  description: "Comfortable and stylish",
}; // Valid with description

console.log(product1); // { name: 'T-Shirt', price: 19.99 }
console.log(product2); // { name: 'Jeans', price: 49.99, description: 'Comfortable and stylish' }
```

**b) Readonly Properties:**

- Use the `readonly` keyword before a property's type to make it read-only.
- The property's value must be initialized during object creation and cannot be modified later.

```typescript
interface Person {
  readonly name: string; // Readonly property (cannot be changed after initialization)
  age: number;
}

let person1: Person = { name: "Bob", age: 25 };

// person1.name = "Alice"; // This will cause a compilation error because 'name' is readonly

console.log(person1.name); // Output: Bob
```

**Remember:**

- Optional and readonly properties offer flexibility in defining object structures while maintaining type safety.

## 3. Function Properties: Adding Behavior to Interfaces

Imagine a blueprint including notes about specific functionalities – interfaces in TypeScript can also define function properties:

```typescript
interface Shape {
  area(): number; // Function property with no return type specified
  getPerimeter(): number; // Function property with a number return type
}

class Square implements Shape {
  // Class implementing the Shape interface
  sideLength: number;

  constructor(sideLength: number) {
    this.sideLength = sideLength;
  }

  area(): number {
    return this.sideLength * this.sideLength;
  }

  getPerimeter(): number {
    return this.sideLength * 4;
  }
}

let square = new Square(5);
console.log(square.area()); // Output: 25 (calculating area)
console.log(square.getPerimeter()); // Output: 20 (calculating perimeter)
```

**Remember:**

- Function properties allow you to define the expected behavior (methods) that objects implementing the interface should possess.

## 4. Unveiling the Mystery: Interface Inheritance (Extending Interfaces)

Imagine an architect creating a blueprint for a specific type of building based on a general building blueprint – interfaces in TypeScript support inheritance:

```typescript
interface Named {
  name: string;
}

interface User extends Named {
  // Interface 'User' inherits from interface 'Named'
  age: number;
}

let user1: User = { name: "Charlie", age: 35 }; // Valid object with properties from both interfaces

console.log(user1.name); // Output: Charlie (accessing inherited property)

interface Employee extends User {
  // Interface 'Employee' further inherits from 'User'
  employeeId: number;
}

let employee1: Employee = { name: "David", age: 40, employeeId: 12345 }; // Valid object with all inherited properties

console.log(employee1); // { name: 'David', age: 40, employeeId: 12345 }
```

**Remember:**

- Interface inheritance allows you to create more specific interfaces by extending existing ones.
- This promotes code reusability and helps define a hierarchy of related object types.

## 5. Code Example: Utilizing Interfaces (Book Library)

Let's build a simple book library example to illustrate interfaces in action:

```typescript
interface Book {
  title: string;
  author: string;
  readonly isbn: string; // Readonly property for ISBN

  // Function property with optional parameter (year published can be omitted)
  getPublicationYear(year?: number): number;
}

class Novel implements Book {
  // Class implementing the Book interface
  title: string;
  author: string;
  isbn: string;
  publicationYear: number;

  constructor(
    title: string,
    author: string,
    isbn: string,
    publicationYear?: number
  ) {
    this.title = title;
    this.author = author;
    this.isbn = isbn;
    this.publicationYear = publicationYear || 2024; // Default value for publication year if not provided
  }

  getPublicationYear(year?: number): number {
    return year || this.publicationYear; // Return provided year or the book's publication year
  }
}

let book1 = new Novel(
  "The Lord of the Rings",
  "J.R.R. Tolkien",
  "978-0261102694",
  1954
);
console.log(
  `Book Title: ${book1.title}, Author: ${book1.author}, ISBN: ${book1.isbn}`
); // Output: Book Title: The Lord of the Rings, Author: J.R.R. Tolkien, ISBN: 978-0261102694

let book2 = new Novel("Pride and Prejudice", "Jane Austen", "978-0140439516");
console.log(
  `Book Title: ${book2.title}, Author: ${book2.author}, Publication Year (default): ${book2.getPublicationYear()}`
); // Output: Book Title: Pride and Prejudice, Author: Jane Austen, Publication Year (default): 2024
```

**Explanation:**

1. We define a `Book` interface with properties and a function property for getting the publication year (with an optional parameter).
2. The `Novel` class implements the `Book` interface, showcasing how interfaces enforce a specific structure for objects.
3. We create book objects with different property values, demonstrating the flexibility of interfaces while maintaining type safety.

**Remember:**

- Interfaces are a cornerstone of object-oriented programming in TypeScript, promoting code maintainability and reusability.

## Conclusion: Mastering Object Blueprints

By understanding interfaces, optional and readonly properties, function properties, and interface inheritance, you've equipped yourself with the essential tools for defining robust and well-structured objects in TypeScript. This empowers you to write clear, concise, and type-safe code. As you progress, explore advanced topics like interface merging and extending interfaces with classes.

**Remember:**

- Mastering interfaces is a crucial step in becoming a proficient TypeScript developer.

## Additional Resources

Here are some resources for further exploration:

- [TypeScript Handbook - Interfaces](https://www.typescriptlang.org/docs/handbook/intro.html)
- [Learn TypeScript - Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)
- [TypeScript Deep Dive Book - Interfaces](https://basarat.gitbook.io/typescript/)

By incorporating these advanced concepts and leveraging the provided resources, you'll be well-equipped to design and implement robust interfaces for your TypeScript projects. Happy coding!
