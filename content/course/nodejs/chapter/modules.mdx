---
index: 2
title: "Node.js Modules"
---

As your Node.js applications grow, code organization becomes crucial. Modules, the building blocks of reusable code, are essential for promoting maintainability, reusability, and efficient development. In this chapter, we'll delve into the world of Node.js modules, specifically focusing on the **CommonJS** module system.

## 1. Introduction to CommonJS Modules: A Pioneering Approach

The **CommonJS** module system is the **default module system** used in Node.js. It provides a standardized way to define modules, export functionalities, and import them into other parts of your application.

**Key Concepts:**

- **Module file:** A JavaScript file containing code that can be exported and used by other modules.
- **Exports:** Values or functions made available for use in other modules.
- **Imports:** The process of bringing functionalities from other modules into your current module.

## 2. Creating and Exporting Modules: Sharing Your Code Gems

**1. Creating a Module:**

Create a file (e.g., `math.js`) with your code:

```javascript
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

// Export the functions
module.exports = {
  add,
  subtract,
};
```

**Explanation:**

- We define two functions, `add` and `subtract`.
- We use `module.exports` to export both functions as an object.

**2. Exporting Specific Functions (Optional):**

You can also export specific functions individually:

```javascript
module.exports.add = add;
module.exports.subtract = subtract;
```

**3. Exporting with exports:**
While less common in modern JavaScript, the older `exports` object can also be used for exporting:

```javascript
// math.js
exports.add = function (x, y) {
  return x + y;
};

exports.subtract = function (x, y) {
  return x - y;
};
```

**Explanation:**

- `exports` is used directly to assign functions to its properties.

## 3. Importing Modules in Node.js: Bringing Code Together

**1. Importing the Module:**

In another file (e.g., `main.js`), you can import the functionalities from `math.js`:

```javascript
const math = require("./math"); // Relative path to the module

const result = math.add(5, 3);
console.log(result); // Output: 8
```

**Explanation:**

- We use `const math = require('./math')` to import the `math` module, assigning it to the `math` constant.
- We then access the exported `add` function using `math.add`.

**2. Importing Specific Exports (Optional):**

If you only need specific functions, you can import them individually:

```javascript
const { add, subtract } = require("./math");

const sum = add(10, 2);
console.log(sum); // Output: 12
```

**Benefits of Modules:**

- **Code organization:** Break down large applications into smaller, manageable modules.
- **Reusability:** Share common functionalities across different parts of your application.
- **Maintainability:** Easier to understand, modify, and test individual modules.

## 4. Module Resolution: Finding the Right Path

Node.js follows a specific algorithm to locate imported modules:

1. **Node.js built-in modules:** If the module name starts with a `.` (dot) or `./` (dot slash), it's assumed to be a relative path within your project.
2. **`node_modules` directory:** If the module name doesn't start with a `.` or `./`, Node.js searches for a directory named `node_modules` in the current directory and its parent directories. This is where third-party modules installed using `npm` (Node Package Manager) are typically located.
3. **Search paths:** If the module is not found in the previous steps, Node.js checks any additional search paths defined in the environment.

By understanding these concepts, you'll be well-equipped to modularize your Node.js applications, promoting clean code structure, efficient development, and effortless maintenance. Remember, practice and experimentation are key to mastering these techniques!
